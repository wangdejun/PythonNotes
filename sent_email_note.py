# 场景：
#     1.我们的网络条件不好
#     2.定期发送大批量邮件，网络条件可能中断代码执行
#     3.需要添加retry功能，当一次没有发送成功的时候，应该选择再一次发送
#     4.抛出异常

# 我第一次解决方案
#send_email_1.py-------------------------------------------------------
    sent_email_state = False#设置标志位，假定发送状态未成功
    try:
        email.send(email)               #成功
        sent_email_state = True         #设置标志位为True
    except Exception,ex:
        sent_email_state = False        #如果执行过程中发生异常，那么就把标志位设置为False

    if not sent_email_state:
        try:
            email.send(email)
        except Exception,ex1:
            print ex1:
#----------------------------------------------------------------------
# 这个方法的问题是，多余地设置了一个标志位，不要这个标志位照样实现同样的功能，为何要多余地设置一个标志位呢？
# 于是有了第二次优化的方法，主要是做了两点：
#     第一：移除多此一举的标志位：
#     第二：第一次抛出异常不抓异常，因为抓了这个异常没有意义，直接执行第二次发送邮件的任务，此刻再抓异常
于是有了如下的解决方法：
#send_email_2.py-------------------------------------------------------
    try:
        email.send(email)
    except Exception,ex:
        try:
            email.send(email):
        except Exception,ex1:
            print ex1:
#----------------------------------------------------------------------
# 这个方法问题在哪里呢？
#     第一，笨
#     第二，表面上是笨，实质上是没有很好地理解业务，
#     第三，不知道重复执行统一任务的处理方法
# 解决问题的方法是老大解决的：
#     第一，采用循环，这样如果想尝试10次，就没有必要写十个一模一样的代码
#     第二，更好地理解业务，业务到底想解决什么问题？答案是网络不好的条件下，当任务执行失败的时候，再一次执行，那么retry与上一次执行任务之间应该有一个时间差，而不是立即执行，这个时间差根据平时业务常识可以设置为1到10s
# 所以有了第二个解决方案：这个方法简直是优雅，带有某种美感
#send_email_3.py-------------------------------------------------------
    for i in range(5)
        try:
            email.send(email)
            #最为关键和精髓的一步，当任务执行成功的时候，break跳出循环，即执行成功，不再try这段代码
            break
        except Exception,ex:
            #又一次体现了对业务的深入了解，当执行任务失败的时候，不是立即retry,而是等待10s钟来再一次尝试
            sleep(10)
#----------------------------------------------------------------------
# 总结：
# 这取决于我们怎样认识循环，多次执行同样的行为时，就应该选择循环，循环此时能够控制
# 你需要更好地理解业务，从根本上而不是语义上来实现需求


